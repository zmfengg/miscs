#! coding=utf-8
'''
* @Author: zmFeng
* @Date: 2019-05-29 09:53:51
* @Last Modified by:   zmFeng
* @Last Modified time: 2019-05-29 09:53:51
local normalizers for a product specification form
'''

from abc import ABC, abstractmethod

from hnjapp.c1rdrs import _fmtpkno
from utilz import NamedList, NamedLists, karatsvc, na, stsizefmt, trimu


class Normalizer(object):
    '''
    class help to validate the form's field one by one
    mainly make use of the sub classes of BaseNrl to complete the task
    '''

    def __init__(self, rdr=None):
        '''
        Args:
            rdr (prdspec.Controller): a reader that can be used to access a workbook by name.
        '''
        self._rdr = rdr
        # in single case, row/colname is None
        # a validation result. those fully pass should not create such record
        self._nrl_mp = None
        self._init_nrls()

    def _hl(self, rng, level, rmks):
        if not rng or level < BaseNrl.LEVEL_MINOR:
            return
        api = rng.api
        api.interior.colorindex = self._get_hl_color(level)
        if rmks:
            api.ClearComments()
            api.AddComment()
            api = api.Comment
            api.Text(Text=rmks)

    @staticmethod
    def _get_hl_color(level):
        if level < 100:
            return 0
        if level < 200:
            return 6
        return 3

    def _init_nrls(self):
        if self._nrl_mp:
            return
        self._nrl_mp = {}
        # maybe from the config file
        tu = TUNrl()
        for x in 'styno qclevel parent docno craft description'.split():
            self._nrl_mp[x] = tu
        self._nrl_mp['dim'] = SizeNrl()
        self._nrl_mp['metal'] = MetalNrl()
        self._nrl_mp['finishing'] = FshNrl()
        self._nrl_mp['parts'] = PartsNrl()
        self._nrl_mp['stone'] = StoneNrl()
        # TODO:: append validators for other single fields and tables
        # singles: lastmodified createdate dim type size netwgt hallmark
        # tables: feature finishing l-type parts stone

    def normalize(self, mp):
        '''
        normalize the result map
        Args:
            mp({string, BaseNrl}): a map generated by prdspec.Controller.read() method
        '''
        logs = []
        for name in mp:
            vdrs = self._nrl_mp.get(name)
            if not vdrs:
                continue
            if isinstance(vdrs, BaseNrl):
                vdrs = (vdrs, )
            for vdr in vdrs:
                lst = vdr.normalize(mp, name)
                if lst:
                    logs.extend(lst)
        # maybe sort the chges by name + row + name
        if logs:
            logs.insert(0, tuple(BaseNrl.nl.colnames))
            logs = NamedLists(logs)
        return mp, logs

    def updateXl(self, logs, highlight=True):
        '''
        high-light the given invalid items(a collection of self._nl_vld)
        '''
        rdr = self._rdr
        for nl in logs:
            if not nl.name:
                print(nl)
                continue
            rng = rdr.get(nl.name)
            rng = rng.get(nl.row, nl.colname) if nl.row else rng.get()
            rng.value = nl.newvalue
            if highlight:
                self._hl(rng, nl.level, nl.remarks)


class BaseNrl(ABC):
    '''
    base normalizer
    '''
    # level:
    # 0 - 99: very small case, can be ignored
    # 100 - 199: advices only, won't affect original value
    # 200 - 255: critical error, fail the program
    nl = NamedList('name row colname oldvalue newvalue level remarks'.split())
    LEVEL_RPLONLY = 0   #only need to do replacement
    LEVEL_MINOR = 50
    LEVEL_ADVICE = 100
    LEVEL_CRITICAL = 200

    def __init__(self, **kwds):
        self._default_level = kwds.get('level', self.LEVEL_MINOR)

    @abstractmethod
    def normalize(self, pmap, name):
        '''
        return None if value is valid, or a tuple of _nl items
        @param pmap: the parent map that contains 'name'
        @param name: the item that need to be validate
        '''

    def _new_log(self, oldval, newval, **kwds):
        '''
        just return the array, returning the NamedList object will lose the array
        '''
        nl = self.nl
        nl.newdata()
        nl.oldvalue, nl.newvalue, nl.level = oldval, newval, self._default_level
        if kwds:
            cm = set(nl.colnames)
        for n, v in kwds.items():
            if n not in cm:
                continue
            if n == 'row':
                nl[n] = v + 1  # the caller is zero based, so + 1
            else:
                nl[n] = v
        return nl.data


class TrNrl(BaseNrl):
    '''
    perform trim only action
    '''

    def __init__(self, *args, **kwds):
        if 'level' not in kwds:
            kwds['level'] = self.LEVEL_RPLONLY
        super().__init__(*args, **kwds)

    def normalize(self, pmap, name):
        old = pmap[name]
        nv = old.strip()
        if nv != old:
            pmap[name] = nv
            return (self._new_log(old, nv, name=name,
                remarks='(%s) trimmed to (%s)' % (old, nv)),)
        return super().normalize(pmap, name)


class TUNrl(BaseNrl):
    '''
    perform trim and upper actions
    '''

    def __init__(self, *args, **kwds):
        if 'level' not in kwds:
            kwds['level'] = self.LEVEL_MINOR
        super().__init__(*args, **kwds)

    def normalize(self, pmap, name):
        old = pmap[name]
        nv = trimu(old)
        if nv != old:
            pmap[name] = nv
            return (self._new_log(old, nv, name=name),)
        return super().normalize(pmap, name)

class KaratNrl(BaseNrl):
    '''
    normalizer for karat
    '''

    def normalize(self, pmap, name):
        k0 = pmap[name]
        nv = rmk = None
        kt = karatsvc.getkarat(k0)
        if kt and kt.name != k0:
            nv, lvl = kt.name, self.LEVEL_ADVICE
            rmk = 'Malform Karat(%s) changed to %s' % (k0, nv)
        elif not kt:
            rmk, lvl = 'Invalid Karat(%s)' % k0, self.LEVEL_CRITICAL
        return  (self._new_log(k0, nv, name=name, remarks=rmk, level=lvl), ) if rmk else None

class SizeNrl(BaseNrl):
    '''
    formatting stone size or object dimension
    '''
    def normalize(self, pmap, name):
        ov = trimu(str(pmap[name]))
        if not ov:
            return None
        sfx = ov.find('SZ')
        if sfx > 0:
            ov, sfx = ov[:sfx], ov[sfx:]
        else:
            sfx = ''
        nv = stsizefmt(str(ov), True) + sfx
        return  (self._new_log(ov, nv, name=name, remarks=None, level=self.LEVEL_RPLONLY),)

class TBaseNrl(BaseNrl):
    '''
    base class for table-based normalizer
    '''

    def __init__(self, *args, **kwds):
        super().__init__(*args, **kwds)
        self._nrl_mp = None
        self._reg_nrls()

    def _reg_nrls(self):
        pass

    def _nrl_one(self, name, row, nl, logs):
        pass

    def _append_log(self, logs, ov, nv, rmk, **kwds):
        if nv == ov:
            return
        if rmk and 'remarks' not in kwds:
            kwds['remarks'] = rmk
        nl = tuple(kwds.get(x) for x in ('nl', 'colname'))
        if all(nl):
            nl, cn = nl
            if cn in nl.colnames:
                nl[cn] = nv
        logs.append(self._new_log(ov, nv, **kwds))

    def normalize(self, pmap, name):
        mtls = pmap.get(name)
        if not mtls:
            return super().normalize(pmap, name)
        logs = []
        for row, nl in enumerate(mtls):
            if self._nrl_mp:
                for cn, nrl in self._nrl_mp.items():
                    var = nrl.normalize(nl, cn)
                    if not var:
                        continue
                    var = self.nl.setdata(var[0])
                    nl[cn] = var.newvalue
                    var.name, var.row, var.colname = name, row + 1, cn
                    logs.append(var.data)
            self._nrl_one(name, row, nl, logs)
        return logs or None


class MetalNrl(TBaseNrl):
    '''
    Metal table normalizer
    '''

    def _reg_nrls(self):
        self._nrl_mp = {
            'remarks': TUNrl(),
            'karat': KaratNrl()
        }

    def _nrl_one(self, name, row, nl, logs):
        colname = 'wgt'
        def _a_log(ov, nv, lvl, rmks):
            self._append_log(logs, ov, nv, rmks, name=name, row=row,
                colname=colname, nl=nl, level=lvl)
        wgt = nl[colname] or 0
        if wgt <= 0:
            _a_log(1, None, self.LEVEL_CRITICAL, 'Wgt(%4.2f) should not be less than or equal to zero' % wgt)
        # a demo about little BL
        kt = karatsvc.getkarat(nl['karat'])
        if kt and kt.category == 'GOLD' and wgt > 3:
            _a_log(None, wgt, self.LEVEL_ADVICE, 'gold weight(%4.2f) greater than %4.2f, maybe error' % (wgt, 3))


class FshNrl(TBaseNrl):
    '''
    normalizer for finishing
    '''

    def _reg_nrls(self):
        tu = TUNrl(level=self.LEVEL_CRITICAL)
        self._nrl_mp = {
            'remarks': TrNrl(),
            'method': tu,
            'spec': tu
        }


class PartsNrl(TBaseNrl):
    '''
    normalizer for Parts
    '''

    def _reg_nrls(self):
        tu = TUNrl()
        self._nrl_mp = {'remarks': TrNrl(), 'type': tu, 'matid': tu}
    # TODO:: implement nlr_one for matId generation or alike

class StoneNrl(TBaseNrl):
    '''
    normalizer for stone
    .minor BL as:
        .Too many stone can not be main stone(ER=2, other=1)
        .There can be only one main stone item
        .Stone Name correction
        .Size to weight
    '''

    def _reg_nrls(self):
        self._nrl_mp = {'size': SizeNrl()}

    def _nrl_one(self, name, row, nl, logs):
        colname = 'matid'
        ov = nl[colname]
        def _log(ov, nv, rmk, level=self.LEVEL_ADVICE):
            self._append_log(logs, ov, nv, rmk, name=name, nl=nl, row=row, colname=colname, level=level)
        if ov:
            nv = _fmtpkno(ov)
            if nv:
                nv = nv[0]
            _log(ov, nv, 'PK# formatted')
        qty, uw, wgt = [nl.get(x) or 0 for x in ('qty', 'unitwgt', 'wgt')]
        if not qty or qty <= 0:
            colname = 'qty'
            _log(ov, 1, 'Invalid qty(%r), set to %d' % (ov, nv))
        if uw * wgt == 0:
            if uw + wgt == 0:
                for colname in ('unitwgt', 'wgt'):
                    _log(ov, None, self.LEVEL_CRITICAL, '(%s) not nullable' % colname)
            else:
                if wgt:
                    colname, uw = 'unitwgt', round(wgt / qty, 3)
                else:
                    colname, uw = 'wgt', round(uw * qty, 3)
                _log(None, uw, '(%s) calculated' % colname)
        for colname, df in (('main', 'N'), ('wgtunit', 'CT')):
            ov = nl[colname]
            nv = trimu(ov or df)
            _log(ov, nv, None, self.LEVEL_RPLONLY)
        if False:
            colname = 'size'
            ov = trimu(str(nl[colname] or na))
            sfx = ov.find('SZ')
            if sfx > 0:
                ov, sfx = ov[:sfx], ov[sfx:]
            else:
                sfx = ''
            nv = stsizefmt(str(ov), True) + sfx
            _log(ov, nv, None, self.LEVEL_RPLONLY)

    def normalize(self, pmap, name):
        logs = super().normalize(pmap, name)
        if not logs:
            logs = []
        stones, ms = pmap[name], []
        for row, nl in enumerate(stones):
            valid = nl.qty == (1 if pmap['type'] != "EARRING" else 2) and stsizefmt(str(nl.size), False) >= "0300"
            ov = nv = nl['main']
            if valid ^ (ov == 'Y'):
                nv = 'Y' if valid else 'N'
                self._append_log(logs, ov, nv, 'this should be %s' % ('main stone' if valid else 'side stone'), nl=nl, name=name, row=row, colname='main', level=self.LEVEL_ADVICE)
            if nv == 'Y':
                ms.append(row)
        if len(ms) > 1:
            for row in ms:
                self._append_log(logs, None, 'Y', 'Multi-Main is not allow', name=name, nl=stones[row], row=row, colname='main', level=self.LEVEL_CRITICAL)
        return logs if logs else None
