#! coding=utf-8
'''
* @Author: zmFeng
* @Date: 2018-06-16 14:20:28
* @Last Modified by:   zmFeng
* @Last Modified time: 2018-06-16 14:20:28
A thread-safe resource manager(ResourceMgr), a Context based Resource consumer(ResourceCtx). An sqlachemy session
resource manager for the ResourceCtx using for cross-method session sharing
'''

import threading
from collections import Iterable
from logging import DEBUG
from copy import copy

from sqlalchemy.orm import sessionmaker

from .common import _logger as logger

__all__ = ["ResourceMgr", "ResourceCtx"]


class ResourceMgr(object):
    """ a thread-safe resource manager, for shared objects like session
        usage example(direct use ResourceMgr):
            def _newcnn():
                return pyodbc.connect(...)
            def _dpcnn(cnn):
                cnn.close()
            cnnmgr = ResourceMgr(_newcnn,_dpcnn)
            cnn,token = cnnmgr.acq()
            try:
                ...
            finally:
                cnnmgr.ret(token)
        usage example(using contextmgr):

        """

    def __init__(self, crtor, dctr):
        """ create a thread-safe resource manager by providng the constructor/destructor
        function which can create/dispose an resource
        @param crtor: the method to create a resource
        @param dctor: the method to dispose a resource
        """
        self._create = crtor
        self._dispose = dctr
        self._storage = {}

    def _getstorage(self):
        return self._storage.setdefault(threading.get_ident(), ([], {}))

    def acq(self, usexisting=True):
        """ return an tuple, the resource as [0] while the token as [1]
        you need to provide the token while ret()
        @param usexisting: when there is existing resource, try to use it
        """
        import random

        stg = self._getstorage()
        if usexisting and stg[0]:
            # this resource is borrow, return will be ignored
            rc = stg[0][-1]
            logger.debug("existing resource(%s) reused", rc)
            return rc, 0
        stk, rmap, token = stg[0], stg[1], 0
        while(not token or token in rmap):
            token = random.randint(1, 65535)
        res = self._create()
        logger.debug("resource(%s) created by acq() with token(%d)" % (res, token))
        rmap[token] = res
        stk.append(res)
        return res, token

    def ret(self, token):
        """
        return the resource to me with the token, if the token was not generated by me,
        nothing happen
        """
        stg = self._getstorage()
        stk, rmap = stg[0], stg[1]

        if not token:
            return
        if not stk:
            raise Exception("Invalid stack status")
        if token not in rmap:
            raise Exception("not returning sth. borrowed from me")
        flag = False
        res = rmap[token]
        flag = res in stk
        if flag:
            stk.remove(res)
        else:
            logger.debug("Failed to return resouce(%s)", res)
            return
        self._dispose(res)
        del rmap[token]
        logger.debug("resource(%s) return and disposed by token(%d)" % (res, token))

    def dispose(self):
        """
        resource all the resources hold by me
        """
        stg = self._getstorage()
        if not stg:
            return
        for tk in [x for x in stg[1].keys()]:
            self.ret(tk)


class SessionMgr(ResourceMgr):
    """ a sqlalchemy engine session manager by providing a sqlalchemy engine """

    def __init__(self, engine, autocommit=False, autoflush=False):
        super().__init__(self._newsess, self.__class__._closesess)
        self._engine = engine
        self._autocommit = autocommit
        self._autoflush = autoflush
        self._smkr = None

    def _newsess(self):
        if not self._smkr:
            self._smkr = sessionmaker(bind=self._engine, autoflush=self._autoflush, autocommit=self._autocommit)
        rc = self._smkr()
        if logger.isEnabledFor(DEBUG):
            logger.debug("session(%s) created by request" % rc)
        return rc

    @classmethod
    def _closesess(cls, sess):
        '''
        it's strange that explicit rollback() fails the outer
        if False:
            # thise will cause sqlalchemy.orm.exc.DetachedInstanceError even you're loading a single object
            # but if you use session.expunge()/expunge_all() before closing, the items is accessable
            # outside the session
            if self._autocommit:
                sess.commit()
            else:
                sess.rollback()
        '''
        if logger.isEnabledFor(DEBUG):
            logger.debug("session(%s) closed", sess)
        sess.close()

    @property
    def engine(self):
        """
        return the internal sqlalchemy engine
        """
        return self._engine

    def dispose(self):
        """
        close the internal sqlalchemy engine if it's available
        """
        logger.debug("sqlachemy engine(%s) disposed", self._engine)
        self._engine.dispose()

    def close(self):
        """
        @see self.dispose()
        """
        self.dispose()


class ResourceCtx(object):
    """
    class wrap resource manager(s) as context manager, which support with statement
    """

    def __init__(self, resmgrs):
        self._src, self._closes, self._ress = (None,) * 3
        if resmgrs:
            self._src = list(resmgrs) if isinstance(resmgrs, Iterable) else [resmgrs]

    @property
    def resources(self):
        ''' return the internal resources as tuple '''
        return list(self._src) if isinstance(self._src) else [self._src, ]

    def __enter__(self):
        if not self._src:
            return None
        self._closes, self._ress, ii = [], [], 0
        for res in self._src:
            if res:
                self._closes.append(True)
                r = res.acq() #(*res.acq(), ii) only works in 3.5+
                self._ress.append((r[0], r[1], ii))
            else:
                self._closes.append(False)
                self._ress.append((None, None, ii))
            ii += 1
        return self._ress[0][0] if len(self._ress) == 1 else [x[0] for x in self._ress]

    def __exit__(self, exc_type, exc_value, traceback):
        if not self._src:
            return None
        cnt = len(self._closes)
        for ii in range(cnt - 1, -1, -1):
            if self._closes[ii]:
                self._src[self._ress[ii][2]].ret(self._ress[ii][1])
        self._closes, self._ress = (None,) * 2
        return not exc_type
